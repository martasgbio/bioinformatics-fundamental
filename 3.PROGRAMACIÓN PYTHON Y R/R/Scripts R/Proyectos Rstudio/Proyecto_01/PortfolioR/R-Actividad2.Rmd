---
title: "R Notebook"
author: "Marta Sevillano González"
output:
  html_document:
    df_print: paged
---

\

(35% de la nota final)

\

Fecha de Entrega: 1ª Convocatoria 26/07/2024 hasta las 23:59

La actividad incluye un conjunto de 10 preguntas a ser resueltos usando el entorno y el lenguaje de programación R. Para la actividad se les dota con un notebook en donde deben cumplir con los siguientes aspectos:

-   Indicar nombre y apellido en el bloque superior del presente archivo.
-   Para cada pregunta tienen disponible un **chunck o bloque de código** en donde presentarán la solución.
-   No deben usar **caminos o rutas absolutas** en las soluciones presentadas pues cada ejercicio será ejecutado para comprobar su exactitud (se penalizará el uso de rutas absolutas pues para ejecutar el código, la docente deberá hacer cambios en su código).
-   Se recomienda colocar los archivos de datos que se necesiten para la realización de la actividad en el mismo directorio en donde se encuentra el notebook.
-   Para las preguntas que necesiten de un conjunto de datos, deberán incluir las instrucciones necesarias para su descarga y lectura.
-   En el aula de 02MBIF se hará la entrega del notebook como archivo con extensión **.Rmd** utilizando la siguiente convención para el nombre del archivo: **R-Actividad-1_SuNombre_SuApellido.Rmd** (p.e. R-Actividad-1_Angela_DiSerio.Rmd) y del correspondiente resultado de la ejecución de su notebook en formato HTML
-   La actividad se realiza de forma individual.

\

# Pregunta 1 (1 punto)

Para la realización de esta actividad evaluada será necesario el uso de diversos paquetes de R. En el siguiente bloque de código indicar las instrucciones en R necesarias para comprobar si los paquetes que ustedes deciden usar han sido instalados o no.

Instalar aquellos paquetes que falten y cargar en memoria todos los paquetes requeridos para resolver la actividad. Tenga en cuenta que algunos paquetes se demoran mucho tiempo en la instalación y por tanto no queremos instalar paquetes que ya han sido instalados previamente.

También, tener en cuenta que si utiliza algún paquete de Bioconductor es necesario verificar si disponemos de BiocManager.

Realizar las verificaciones de forma automática para que cualquier persona pueda ejecutar la actividad sin problemas.

Este tipo de verificación lo hemos estado haciendo en casi todas las prácticas realizadas durante las sesiones de la asignatura (Buenas Prácticas).

```{r Pregunta 1}
# Lista de paquetes a instalar 
list.of.packages = c("R.utils","seqinr","tibble","stringr","tidyr","readxl","ggplot2","ape")
list.of.packages
list.of.packages_Bio = c("GEOquery")
list.of.packages_Bio

# Verificar paquetes no instalados y si hay paquetes que faltan los instala 
new.packages = list.of.packages[!(list.of.packages %in% installed.packages())]
if(length(new.packages)> 0) install.packages(new.packages)

new.packages = list.of.packages_Bio[!(list.of.packages_Bio %in% installed.packages())]
if(length(new.packages)> 0) BiocManager::install(new.packages,version = BiocManager::version())


# uso de lapply para cargar todos los paquetes en memoria 
invisible(lapply(list.of.packages, FUN=library, character.only=TRUE))
invisible(lapply(list.of.packages_Bio, FUN=library, character.only=TRUE))
rm(list.of.packages, new.packages)



```

\

# Pregunta 2 (1 punto)

Existen otros paquetes que también permiten acceder y manipular datos genómicos, como por ejemplo el paquete **ape**.

En este paquete disponemos de la función **read.GenBank()**. Esta función se conecta a la base de datos GenBank y lee secuencias de nucleótidos utilizando el número de acceso que proporcionamos como argumento. Revisar la documentación de la función read.GenBank() para conocer los argumentos de la misma. ¿qué sucede cuando usamos el argumento as.character=FALSE? ¿qué sucede cuando el argumento as.character=TRUE? ¿Cuál debemos usar por conveniencia?

En el siguiente bloque de código, descargar los datos correspondientes a la secuencia del virus del dengue tipo 3 (DEN-3) con *accession number* **NC_001475**

```{r}
library(ape)

# as.character = FALSE, da un tipo de objeto de la clase "DNAbin", secuencias de ADN en formato binario que son más compactos
# as.character = TRUE, da una lista de cadenas de caracteres  
# El DNAbin es más rápido de manejar, para trabajar con grandes conjuntos de secuencias. Pero en este caso trabajaría con as.character TRUE, ya que deja hacer manipulaciones simples en la cadena de ADN

access.nb = "NC_001475"
secuencia = read.GenBank(access.nb, seq.names = access.nb, species.names = TRUE, 
                         as.character = FALSE, chunk.size = 400, quiet = TRUE, type = "DNA")

secuencia2 = read.GenBank(access.nb, seq.names = access.nb, species.names = TRUE, 
                         as.character = TRUE, chunk.size = 400, quiet = TRUE, type = "DNA")

```

\

# Pregunta 3 (1 punto)

Utilizando los datos descargados en la pregunta 2, responda: - Tipo de objeto devuelto por **read.GenBank()** - ¿Cuántas secuencias incluye? - ¿Cuál es la longitud de la secuencia? o de las secuencias? - Usar la función print para mostrar los resultados

Indicar la secuencia de instrucciones dentro del bloque de código:

```{r}
class(secuencia2)
print(secuencia2)
length(secuencia2)
length(secuencia2[[1]])

# Devuelve una lista
# Tiene una sola secuencia
# La longitud de la secuencia es de 10707

```

\

# Pregunta 4 (0,5 punto)

Salvar los datos de la secuencia completa del virus del **Dengue tipo 3** en un archivo FASTA identificado con el nombre **DEN-3.FASTA**"

```{r}
# almacenamiento de la secuencia en formato FASTA
write.fasta(names="DEN-3.FASTA", sequences=secuencia2, file.out="DEN-3.FASTA")

# comprobación de que el nuevo archivo FASTA se puede leer
secdengue = read.fasta(file="DEN-3.FASTA")
class(secdengue)
length(secdengue)
length(secdengue[[1]])

```

\

# Pregunta 5 (1,5 puntos)

a.  Procesar el archivo adjunto ls_orchid.fasta

```{r}
datos_orchid = read.fasta(file="ls_orchid.fasta")
```

b.  ¿Cuántas secuencias se han descargado ?

```{r}
print(paste("El número de secuencias es ", length(datos_orchid)))
# se han descargado 94 secuencias
```

c.  ¿cuál es la longitud de cada secuencia?

```{r}
# con sapply se aplica la función para todas las secuencias del archivo
longitud_secuencias = sapply(datos_orchid, FUN=length)
View(longitud_secuencias)
head((longitud_secuencias),5)
```

d.  ¿Cuántos nucleótidos A, C, T y G, hay en cada una de las secuencias?

```{r}
# utilizamos la función count para contar los nucleótidos y sapply para aplicarlo a todas las secuencias
Nucleotidos=sapply(datos_orchid, FUN=count,1)
View(Nucleotidos)
# se puede poner los datos como data frame para hacerlo de una forma más visual
Nucleotidos[1:3,1:10]
Nucleotidos = t(Nucleotidos)
Nucleotidos = as.data.frame(Nucleotidos)
Nucleotidos = Nucleotidos %>% tibble::rownames_to_column( "Identificador_Secuencias")

```

\

------------------------------------------------------------------------

------------------------------------------------------------------------

\

Para las siguientes preguntas vamos a utilizar el archivo **ActividadR.csv** que contiene un conjunto de datos de expresión genética.

Un poco de contexto sobre los datos a utilizar en las siguientes preguntas.

Brauer 2008 utilizó micromatrices para probar el efecto de la inanición y la tasa de crecimiento en la levadura de panadería. Básicamente, si le da a la levadura muchos nutrientes (un medio rico), pero restringe drásticamente el suministro de un nutriente en particular, puede controlar la tasa de crecimiento al nivel que desee. Por ejemplo, se podría limitar el suministro de glucosa (azúcar que la célula metaboliza para obtener energía y carbono), de leucina (un aminoácido esencial) o de amonio (una fuente de nitrógeno) de la levadura.

"Matar de hambre" a la levadura de estos nutrientes nos permite encontrar genes que:

-   **Aumentan o disminuyen su actividad en respuesta a la tasa de crecimiento**.

-   **Respondan de manera diferente cuando se limiten diferentes nutrientes**.

\

# Pregunta 6 (0,5 puntos)

Importar los datos contenidos en el archivo **ActividadR.csv**

```{r}
ActividadR = read.csv(file="ActividadR.csv")
View(ActividadR)
str(ActividadR)
class(ActividadR)
print(ActividadR)
```

Al revisar la estructura de los datos, notaréis que tenemos una serie de columnas identificadas como G0.05, G0.1, ..., N0.05, .., P0.05, ... etc.

Cada una de estas columnas representa valores de expresión genética para la muestra. Por ejemplo, la columna G0.05 significa que el nutriente limitante era la glucosa y la tasa de crecimiento era 0,05. Un valor más alto significa que el gen se expresó más en esa muestra, un valor más bajo significa que el gen se expresó menos. En total, la levadura se cultivó con seis nutrientes limitantes y seis tasas de crecimiento, lo que da como resultado 36 muestras y, por lo tanto, tenemos en el conjunto de datos 36 columnas de datos de expresión genética.

Los nombres de estas columnas contienen los valores de dos variables:

-   nutrientes (G,N,P,S,L,U) y
-   tasa de crecimiento (0,05 - 0,3).

Por tanto, los datos no se encuentran en formato **tidy** lo que puede dificultar su procesamiento y visualización. Es necesario transformar este conjunto de datos a un formato **long**.

\

# Pregunta 7 (1,5 puntos)

Transformar los datos al formato **long** en donde tendremos una columna que indica el nutriente, otra columna indica la tasa de crecimiento y una tercera columna representa la expresión genética.

Ayuda: Para lograr la separación en 3 columnas se necesitarán dos pasos. En un primer paso se obtiene una columna que contiene el nutriente y la tasa de crecimiento (ejemplo G0.05, G0.1 ) y otra columna con la expresión genética. En el segundo paso debe separar la columna que contiene por ejemplo G0.05 en dos columnas: una con el nutriente G y la otra con la tasa de crecimiento (0.05). Revisar la documentación de la función **separate()**

Transformación de los datos:

```{r}
library(tidyr)

# Para transformar a long se puede usar la función gather, indicando los nombres de las columnas que quieres obtener y exceptuando el resto de columnas. 
# Después como se ha sugerido se separa una de las columnas con la función separate, indicando el nombre de la columna que se quiere modificar y el nombre de las dos columna nuevas. Con sep le estamos indicando de qué forma tiene que separarlo, por un lado las letras en la primera columna y por el oro lado los numeros en la siguiente columna. 
ArchivoR_long = ActividadR %>% gather(Nutriente.tasa, Expresión_genética, - name, -BP, -MF, -systematic_name)
ArchivoR_long = ArchivoR_long %>% separate(col = "Nutriente.tasa", 
into = c("Nutriente", "Tasa_crecimiento"), 
sep = "(?<=[A-Za-z])[0-9]",
remove = TRUE,
convert = TRUE, 
)

```

\

En caso de no lograr hacer la transformación de los datos, importar el conjunto de datos en formato long para continuar con el resto de las preguntas.

```{r}
# Importar "ActividadR_long.csv"


```

\

# Pregunta 8 (1 punto)

Supongamos que nos interesa ver el comportamiento del gen de la levadura identificada con el nombre **LEU4**. Tendremos 36 valores que corresponden a la expresión resultante para los 6 nutrientes y las 6 tasas de crecimiento.

Mostrar un gráfico de líneas en donde cada línea representa un nutriente y dichas líneas nos muestran como la tasa de crecimiento afecta a la expresión genética.

```{r}
library(ggplot2)
library(dplyr)

# En estre caso he creado un nuevo data frame seleccionando solo los datos que corresponden al gen LEU4
LEU4 = ArchivoR_long %>% filter(name == "LEU4")

ggplot(data=LEU4, mapping= aes(x=Tasa_crecimiento, y = Expresión_genética, color=Nutriente)) +         
  geom_line(size=1) + labs (x="Tasa de crecimiento", y="Expresión del gen LEU4")

# o también se puede hacer directamente mediante otro pipe 
ArchivoR_long %>% filter(name == "LEU4") %>% ggplot(, mapping= aes(x=Tasa_crecimiento, y = Expresión_genética, color=Nutriente)) +         
  geom_line(size=1) + labs (x="Tasa de crecimiento", y="Expresión del gen LEU4")



```

\

# Pregunta 9 (1 punto)

Mostrar gráficos de línea para todos los genes que participan en el proceso de biosíntesis de leucina (columna BP valor "leucine biosynthesis"). (Ayuda: funciones de la familia facet para separar cada uno de los genes LEU).

```{r}

ArchivoR_long %>% filter(BP == "leucine biosynthesis") %>% ggplot(, mapping= aes(x=Tasa_crecimiento, y = Expresión_genética, color=Nutriente)) +         
  geom_line(size=1) + labs (x="Tasa de crecimiento", y="Expresión del gen") + facet_wrap(~name)

```

\

# Pregunta 10 (1 punto)

Modificar el gráfico de la pregunta 9 para que en este caso sea un gráfico de puntos para los distintos genes que participan en el proceso de biosíntesis de leucina e incluir **líneas de mejor ajuste** para observar la tendencia de los datos en cada uno de los genes.

```{r}

# cambiamos geom_line por geom_point para hacer el gráfico de puntos y para incluir las líneas de mejor ajuste utilizamos geom_smooth

ArchivoR_long %>% filter(BP == "leucine biosynthesis") %>% ggplot(, mapping= aes(x=Tasa_crecimiento, y = Expresión_genética, color=Nutriente)) +         
  geom_point(size=1) + labs (x="Tasa de crecimiento", y="Expresión del gen") + geom_smooth(method = "lm", se = FALSE, linetype = "solid", size= 1) + facet_wrap(~name)



```
